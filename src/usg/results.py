# Ubuntu Security Guide
# Copyright (C) 2025 Canonical Ltd.
#
# SPDX-License-Identifier: GPL-3.0-only
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3,
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranties of
# MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
# PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see http://www.gnu.org/licenses/.

"""Classes for storing and processing usg audit results and artifacts."""

import logging
import shutil
from dataclasses import dataclass
from pathlib import Path
from typing import Any

from usg.exceptions import FileMoveError

logger = logging.getLogger(__name__)


@dataclass
class BackendArtifact:
    """Artifact generated by a backend operation."""

    kind: str
    path: Path
    metadata: dict[str, Any]

    def move(self, new_path: Path | str) -> None:
        """Move the file to a new location and update the path."""
        new_file_path = Path(new_path).resolve()
        logger.debug(f"Moving {self.path} to {new_file_path}")
        try:
            new_file_path.parent.mkdir(parents=True, exist_ok=True)
            shutil.move(self.path, new_file_path)
        except Exception as e:
            raise FileMoveError(
                f"Failed to move {self.path} to {new_file_path}: {e}"
            ) from e
        self.path = new_file_path


class BackendArtifacts(list[BackendArtifact]):
    """List of artifacts generated by a backend operation."""

    def add_artifact(
        self, kind: str, path: Path | str, metadata: dict[str, Any] | None = None
    ) -> None:
        """Add a file to the list.

        Args:
            kind: Type of the file
            path: Path to the file
            metadata: Metadata for the file

        Returns:
            None

        """
        logger.debug(f"Adding artifact of type {kind}: {path}")
        if [True for a in self if a.kind == kind]:
            raise ValueError(f"Artifact with kind {kind} already exists")
        self.append(BackendArtifact(kind, Path(path).resolve(), metadata or {}))

    def get_by_type(self, kind: str) -> BackendArtifact:
        """Get a file by type. Raise ValueError if no file is found.

        Args:
            kind: Type of the file to get

        Returns:
            BackendArtifact object

        Raises:
            ValueError: if no file is found

        """
        logger.debug(f"Getting artifact by type: {kind}")
        for file in self:
            if file.kind == kind:
                return file
        raise ValueError(f"No file found with kind {kind}")

    def move_to_dir(self, dir_path: Path | str, parent_dir_filter: Path | str) -> None:
        """Move the artifacts to the given directory if they are in parent_dir_filter.

        Args:
            dir_path: Path to the directory to move the artifacts to
            parent_dir_filter: Path to the parent directory to filter the artifacts by

        """
        logger.debug(f"Moving artifacts to {dir_path}")
        dir_path = Path(dir_path).resolve()
        parent_dir_filter = Path(parent_dir_filter).resolve()
        for artifact in self:
            artifact_full_path = artifact.path.resolve()
            if parent_dir_filter in artifact_full_path.parents:
                logger.debug(
                    f"Moving artifact {artifact_full_path}."
                    )
                artifact.move(dir_path / artifact.path.name)
            else:
                logger.debug(
                    f"Skipping artifact {artifact_full_path}. "
                    f"Not in {parent_dir_filter}."
                    )


@dataclass
class AuditResult:
    """Result of an audit."""

    rule_name: str
    state: str
    message: str


class AuditResults(list):
    """List of audit results."""

    def add_result(self, rule_name: str, state: str, message: str) -> None:
        """Add a result to the list.

        Args:
            rule_name: Name of the rule
            state: State of the rule
            message: Message of the rule

        """
        r = AuditResult(rule_name, state, message)
        logger.debug(f"Adding result: {r}")
        self.append(r)

    def get_summary(self) -> str:
        """Get a summary of the audit results.

        Returns:
            string representation of the audit results summary

        """
        result_types = [
            "pass",
            "fail",
            "notapplicable",
            "error",
            "notchecked",
            "unknown",
        ]
        result_counts = dict.fromkeys(result_types, 0)

        for result in self:
            if result.state in result_types:
                result_counts[result.state] += 1
            else:
                result_counts["unknown"] += 1
        return """\
Pass:  {pass}
Fail:  {fail}
Error: {error}
NotChecked: {notchecked}
Unknown: {unknown}
N/A:   {notapplicable}
""".format(**result_counts)
